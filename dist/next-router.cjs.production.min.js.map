{"version":3,"file":"next-router.cjs.production.min.js","sources":["../src/utils/index.ts","../src/Route/Route.ts","../src/Router/Router.ts","../src/utils/events.ts","../src/Link/Link.tsx","../src/hocs/withNextRouter.tsx","../src/index.ts"],"sourcesContent":["export const getUrlParams = (queryString: string) => {\r\n  if (!queryString) {\r\n    return {};\r\n  }\r\n  let hashes = queryString.split('&');\r\n  let params: { [key: string]: string | null } = {};\r\n  hashes.forEach(hash => {\r\n    let [key, val] = hash.split('=');\r\n    if (key) {\r\n      params[key] = val ? decodeURIComponent(val) : null;\r\n    }\r\n  });\r\n\r\n  return params;\r\n};\r\n","import { PathFunction, Key, pathToRegexp, compile } from 'path-to-regexp';\r\nimport { getUrlParams } from './../utils';\r\nimport { RouteMatch } from '../types';\r\n\r\nclass Route {\r\n  private page: string;\r\n  private keys: Key[];\r\n  private compiled: PathFunction;\r\n  private regex: RegExp;\r\n\r\n  constructor(pattern: string, page: string) {\r\n    this.page = page;\r\n    this.compiled = compile(pattern, { encode: encodeURIComponent });\r\n    this.keys = [];\r\n    // @ts-ignore\r\n    this.regex = pathToRegexp(pattern, this.keys);\r\n  }\r\n\r\n  private valuesToParams(values: any, keys: Key[]) {\r\n    return values.reduce((params: any, val: any, i: number) => {\r\n      if (val === undefined) return params;\r\n      return Object.assign(params, {\r\n        [keys[i].name]: decodeURIComponent(val),\r\n      });\r\n    }, {});\r\n  }\r\n\r\n  match(asPath: string): RouteMatch {\r\n    const asPathSplitted = asPath.split('#');\r\n    const asPathNoHash = asPathSplitted[0];\r\n\r\n    const asPathNoHashSplitted = asPathNoHash.split('?');\r\n    const asPathNoHashNoQuery = asPathNoHashSplitted[0];\r\n\r\n    // get query params\r\n    let queryParams = {};\r\n    if (asPathNoHashSplitted.length > 1) {\r\n      queryParams = getUrlParams(asPathNoHashSplitted[1]);\r\n    }\r\n\r\n    // get hash\r\n    const hash = asPathSplitted.length > 1 ? asPathSplitted[1] : '';\r\n\r\n    const match = this.regex.exec(asPathNoHashNoQuery);\r\n    if (match !== null) {\r\n      const params = this.valuesToParams(match.slice(1), this.keys);\r\n      return {\r\n        params,\r\n        query: queryParams,\r\n        hash,\r\n        path: asPath,\r\n        page: this.page,\r\n        matched: true,\r\n      };\r\n    }\r\n    return {\r\n      params: {},\r\n      query: queryParams,\r\n      hash: hash,\r\n      path: asPath,\r\n      page: '',\r\n      matched: false,\r\n    };\r\n  }\r\n\r\n  assemble(params: any): string {\r\n    const compiled = this.compiled(params);\r\n    return compiled === '' ? '/' : compiled.replace(/%23/g, '#');\r\n  }\r\n\r\n  getPage(): string {\r\n    return this.page;\r\n  }\r\n}\r\n\r\nexport default Route;\r\n","import { default as NextRouter } from 'next/router';\r\nimport {\r\n  RouterMatch,\r\n  CurrentRoute,\r\n  Routes,\r\n  RouteAssemble,\r\n  LinkProps,\r\n} from '../types';\r\nimport Route from '../Route';\r\nimport events, { Events } from '../utils/events';\r\n\r\nclass Router {\r\n  private routes: { [key: string]: Route } = {};\r\n  private currentRoute: CurrentRoute = null;\r\n  public events: Events;\r\n\r\n  constructor(routes: Routes) {\r\n    this.setRoutes(routes);\r\n    this.events = events(this);\r\n  }\r\n\r\n  setRoutes(routes: Routes): void {\r\n    this.routes = {};\r\n    this.addRoutes(routes);\r\n  }\r\n\r\n  addRoutes(routes: Routes): void {\r\n    for (const route in routes) {\r\n      if (!routes.hasOwnProperty(route)) {\r\n        continue;\r\n      }\r\n      this.routes[route] = new Route(routes[route].pattern, routes[route].page);\r\n    }\r\n  }\r\n\r\n  getRoutes(): { [key: string]: Route } {\r\n    return this.routes;\r\n  }\r\n\r\n  match(asPath: string): RouterMatch {\r\n    for (const route in this.routes) {\r\n      if (!this.routes.hasOwnProperty(route)) {\r\n        continue;\r\n      }\r\n\r\n      const matched = this.routes[route].match(asPath);\r\n      if (matched.matched) {\r\n        return { ...matched, route };\r\n      }\r\n    }\r\n\r\n    return {\r\n      route: '',\r\n      params: {},\r\n      query: {},\r\n      path: asPath,\r\n      page: '',\r\n      hash: '',\r\n      matched: false,\r\n    };\r\n  }\r\n\r\n  assemble(route: string, params: any): RouteAssemble {\r\n    if (this.routes[route]) {\r\n      return {\r\n        path: this.routes[route].assemble(params),\r\n        page: this.routes[route].getPage(),\r\n      };\r\n    }\r\n    throw new Error('next-router: No route matched');\r\n  }\r\n\r\n  getLinkProps(route: string, params: any = {}, hash: string = ''): LinkProps {\r\n    const assembled = this.assemble(route, params);\r\n    const hashSuffix = hash !== '' ? `#${hash}` : '';\r\n    return {\r\n      href: { pathname: assembled.page, query: params },\r\n      as: `${assembled.path}${hashSuffix}`,\r\n    };\r\n  }\r\n\r\n  getLinkPropsFromHref(\r\n    href: string,\r\n    transformFn: (href: string) => string = href => href\r\n  ): LinkProps {\r\n    const hrefSlash = href.substr(0, 1) !== '/' ? `/${href}` : href;\r\n    const match = this.match(transformFn(hrefSlash));\r\n    if (match.matched) {\r\n      return this.getLinkProps(match.route, match.params, match.hash);\r\n    }\r\n    return {\r\n      href,\r\n      as: href,\r\n    };\r\n  }\r\n\r\n  push(\r\n    route: string,\r\n    params: any = {},\r\n    hash: string = '',\r\n    options: any = {}\r\n  ): Promise<boolean> {\r\n    const props = this.getLinkProps(route, params, hash);\r\n    return NextRouter.push(props.href, props.as, options);\r\n  }\r\n\r\n  pushHref(href: string, options: any = {}): Promise<boolean> {\r\n    const props = this.getLinkPropsFromHref(href);\r\n    return NextRouter.push(props.href, props.as, options);\r\n  }\r\n\r\n  replace(\r\n    route: string,\r\n    params: any = {},\r\n    hash: string = '',\r\n    options: any = {}\r\n  ): Promise<boolean> {\r\n    const props = this.getLinkProps(route, params, hash);\r\n    return NextRouter.replace(props.href, props.as, options);\r\n  }\r\n\r\n  replaceHref(href: string, options: any = {}): Promise<boolean> {\r\n    const props = this.getLinkPropsFromHref(href);\r\n    return NextRouter.replace(props.href, props.as, options);\r\n  }\r\n\r\n  getRequestHandler(renderFunction: Function) {\r\n    return (req: any, res: any, next: any) => {\r\n      // don't render next url's\r\n      const isNextUrl = req.url.match(/^\\/_next|^\\/static/);\r\n      if (isNextUrl) {\r\n        return next();\r\n      }\r\n\r\n      // try to match request url\r\n      const { matched, route, page, params, query, hash } = this.match(req.url);\r\n\r\n      if (matched) {\r\n        // set current route for later access\r\n        this.setCurrentRoute({ route, page, params, query, hash });\r\n\r\n        // call render function\r\n        if (renderFunction) {\r\n          return renderFunction(req, res, page, params, query, route);\r\n        }\r\n      }\r\n\r\n      next();\r\n    };\r\n  }\r\n\r\n  currentRouteFromMatch(routerMatch: RouterMatch): CurrentRoute {\r\n    const { route, page, params, query, hash } = routerMatch;\r\n    return {\r\n      route,\r\n      page,\r\n      params,\r\n      query,\r\n      hash,\r\n    };\r\n  }\r\n\r\n  setCurrentRoute(currentRoute: CurrentRoute) {\r\n    this.currentRoute = currentRoute;\r\n  }\r\n\r\n  getCurrentRoute(): CurrentRoute {\r\n    return this.currentRoute;\r\n  }\r\n}\r\n\r\nexport default Router;\r\n","import { default as NextRouter } from 'next/router';\r\nimport Router from 'Router/Router';\r\n\r\ntype Handler = (...evts: any[]) => void;\r\n\r\nexport type Events = {\r\n  on(type: string, handler: Handler): void;\r\n  off(type: string, handler: Handler): void;\r\n};\r\n\r\ntype Handlers = { handler: Handler; handlerRouter: Handler };\r\n\r\ntype Cache = { [s: string]: Handlers[] };\r\n\r\nconst getHandlerRouter = (router: Router, handler: Handler) => (\r\n  ...evts: any[]\r\n) => {\r\n  let url = evts[0];\r\n  if (evts.length > 1 && typeof evts[1] === \"string\") {\r\n    url = evts[1];\r\n  }\r\n  const routerMatch = router.match(url);\r\n  const currentRoute = router.currentRouteFromMatch(routerMatch);\r\n  if (evts.length === 1) {\r\n    handler(currentRoute);\r\n  } else {\r\n    handler(evts[0], currentRoute);\r\n  }\r\n};\r\n\r\nconst findHandlersIndex = (arr: Handlers[], handler: Handler) => {\r\n  return arr.findIndex(handlers => {\r\n    return handlers.handler === handler;\r\n  });\r\n};\r\n\r\nexport default function events(router: Router): Events {\r\n  const all: Cache = Object.create(null);\r\n\r\n  return {\r\n    on(type: string, handler: Handler) {\r\n      const handlerRouter = getHandlerRouter(router, handler);\r\n      NextRouter.events.on(type, handlerRouter);\r\n      (all[type] || (all[type] = [])).push({ handler, handlerRouter });\r\n    },\r\n    off(type: string, handler: Handler) {\r\n      if (all[type]) {\r\n        const handlersIndex = findHandlersIndex(all[type], handler);\r\n        if (handlersIndex >= 0) {\r\n          const handlerRouter = all[type][handlersIndex].handlerRouter;\r\n          NextRouter.events.off(type, handlerRouter);\r\n          all[type].splice(handlersIndex, 1);\r\n        }\r\n      }\r\n    },\r\n  };\r\n}\r\n","import * as React from 'react';\r\nimport NextLink from 'next/link';\r\nimport Router from '../Router';\r\n\r\nexport type LinkProps = {\r\n  route?: string;\r\n  params?: any;\r\n  hash?: string;\r\n  href?: string;\r\n  children: React.ReactElement<any>;\r\n  [key: string]: any;\r\n};\r\n\r\nconst Link = (router: Router) => ({\r\n  route,\r\n  params = {},\r\n  hash = '',\r\n  href,\r\n  children,\r\n  ...props\r\n}: LinkProps) => {\r\n  if (!route && !href) {\r\n    throw new Error(\r\n      'next-router: You have to provide a route or a href to the Link'\r\n    );\r\n  }\r\n\r\n  let mergedProps;\r\n\r\n  if (route) {\r\n    mergedProps = { ...router.getLinkProps(route, params, hash), ...props };\r\n  } else {\r\n    mergedProps = { ...router.getLinkPropsFromHref(href || ''), ...props };\r\n  }\r\n\r\n  return <NextLink {...mergedProps}>{children}</NextLink>;\r\n};\r\n\r\nexport default Link;\r\n","import * as React from 'react';\r\nimport { NextComponentType } from 'next';\r\nimport { AppContext } from 'next/app';\r\nimport Router from './../Router';\r\nimport { CurrentRoute, RouterMatch } from './../types';\r\n\r\ninterface WrappedAppProps {\r\n  initialProps: any;\r\n  nextRouter_currentRoute: CurrentRoute;\r\n}\r\n\r\nconst getRouterMatch = (appCtx: AppContext, router: Router): RouterMatch => {\r\n  const asPath = appCtx.ctx.asPath || '';\r\n  return router.match(asPath);\r\n};\r\n\r\nexport default (\r\n  router: Router,\r\n  getRouterMatchFunction?: (appCtx: AppContext, router: Router) => RouterMatch\r\n) => {\r\n  if (!getRouterMatchFunction) {\r\n    getRouterMatchFunction = getRouterMatch;\r\n  }\r\n\r\n  return (App: NextComponentType | any) =>\r\n    class WrappedApp extends React.Component<WrappedAppProps> {\r\n      public static getInitialProps = async (appCtx: AppContext) => {\r\n        let initialProps = {};\r\n\r\n        let routerMatch: RouterMatch = {\r\n          route: '',\r\n          params: {},\r\n          query: {},\r\n          path: '',\r\n          page: '',\r\n          hash: '',\r\n          matched: false,\r\n        };\r\n\r\n        if (getRouterMatchFunction) {\r\n          routerMatch = getRouterMatchFunction(appCtx, router);\r\n        }\r\n\r\n        if (!routerMatch.matched) {\r\n          if (appCtx.ctx.res) {\r\n            appCtx.ctx.res.statusCode = 404;\r\n          }\r\n        }\r\n\r\n        const { route, page, params, query, hash } = routerMatch;\r\n        const nextRouter_currentRoute = { route, page, params, query, hash };\r\n        router.setCurrentRoute(nextRouter_currentRoute);\r\n\r\n        appCtx.ctx.query = { ...query, ...params };\r\n\r\n        if ('getInitialProps' in App) {\r\n          initialProps = await App.getInitialProps.call(App, appCtx);\r\n        }\r\n\r\n        return {\r\n          nextRouter_currentRoute,\r\n          initialProps,\r\n        };\r\n      };\r\n\r\n      public render() {\r\n        const { initialProps, nextRouter_currentRoute, ...props } = this.props;\r\n\r\n        // set current route on hydration\r\n        if (!router.getCurrentRoute()) {\r\n          router.setCurrentRoute(nextRouter_currentRoute);\r\n        }\r\n\r\n        return <App {...props} {...initialProps} />;\r\n      }\r\n    };\r\n};\r\n","import NextLink from 'next/link';\r\nimport Router from './Router';\r\nimport Link from './Link';\r\nimport withNextRouterFactory from './hocs/withNextRouter';\r\nimport { CurrentRoute, RouterMatch, Routes } from './types';\r\nimport { AppContext } from 'next/app';\r\n\r\nlet router: Router;\r\nlet link;\r\nlet withNextRouter;\r\n\r\ninterface Constructable<T> {\r\n  new (routes: Routes): T;\r\n}\r\n\r\nexport const init = (\r\n  routes: Routes,\r\n  RouterClass?: Constructable<Router>,\r\n  LinkFactory?: (router: Router) => typeof NextLink,\r\n  getRouterMatchFunction?: (appCtx: AppContext, router: Router) => RouterMatch\r\n) => {\r\n  router = RouterClass ? new RouterClass(routes) : new Router(routes);\r\n  link = LinkFactory ? LinkFactory(router) : Link(router);\r\n  withNextRouter = withNextRouterFactory(router, getRouterMatchFunction);\r\n};\r\n\r\nconst useRouter = (): CurrentRoute => {\r\n  if (!router) {\r\n    throw new Error(\r\n      'next-router: Router is not set. You have to initialize next-router first.'\r\n    );\r\n  }\r\n  return router.getCurrentRoute();\r\n};\r\n\r\nexport { Router as RouterClass, Link as LinkFactory, withNextRouterFactory };\r\nexport { router as Router };\r\nexport { link as Link };\r\nexport { withNextRouter, useRouter };\r\nexport { default as RouteClass } from './Route';\r\nexport {\r\n  Routes,\r\n  RouteMatch,\r\n  RouteAssemble,\r\n  LinkProps,\r\n  CurrentRoute,\r\n} from './types';\r\n"],"names":["Route","pattern","page","compiled","compile","encode","encodeURIComponent","keys","regex","pathToRegexp","this","valuesToParams","values","reduce","params","val","i","undefined","Object","assign","name","decodeURIComponent","match","asPath","asPathSplitted","split","asPathNoHashSplitted","asPathNoHashNoQuery","queryParams","length","queryString","hashes","forEach","hash","key","getUrlParams","exec","slice","query","path","matched","assemble","replace","getPage","Router","routes","router","all","setRoutes","events","create","on","type","handler","handlerRouter","url","arguments","routerMatch","currentRoute","currentRouteFromMatch","getHandlerRouter","NextRouter","push","off","handlersIndex","arr","findIndex","handlers","findHandlersIndex","splice","addRoutes","route","hasOwnProperty","getRoutes","Error","getLinkProps","assembled","href","pathname","as","getLinkPropsFromHref","transformFn","hrefSlash","substr","options","props","pushHref","replaceHref","getRequestHandler","renderFunction","req","res","next","_this","setCurrentRoute","getCurrentRoute","Link","mergedProps","children","React","NextLink","getRouterMatch","appCtx","ctx","getRouterMatchFunction","App","render","initialProps","nextRouter_currentRoute","statusCode","getInitialProps","call","RouterClass","LinkFactory","link","withNextRouter","withNextRouterFactory"],"mappings":"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"}